# “老司机”也会在闭包上翻车

### 前言：

&emsp;闭包是 JavaScript 中最基本也是最重要的概念之一，很多开发者都对它“了如指掌”。可是，闭包又绝对不是一个单一的概念：它涉及作用域、作用城链、执行上下文、内存管理等多重知识点。 不管是新手还是“老司机”，经常会出现“我觉得我弄懂了闭包，但还是会在一些场景下翻车” 的情况。本篇将对这个话题进行梳理，并通过“应试题"来强化理解闭包。



### 基础知识

&emsp;如同前面所说的，闭包不是一个单一的概念，在直击闭包概念之前，我们先来了解一-下与之相关的必备知识点。



### 作用域

&emsp;作用域可以被理解为某种规则下的限定范围，该规则用于指导开发者如何在特定场景下查找变量。任何语言中都有作用城的概念，同一种语言在演进过程中也会不断完善其作用域规则。比如、在 JavaScript 中，ES6 出现之前，一般来说只有函数作用域和全局作用域之分。



#### 函数作用域和全局作用域

​	&emsp;大家应该非常熟悉函数作用域了，例如，执行以下 foo 函数时，变量 a 在函数 foo 的作用域内，因此可以在函数体内正常访问该变量，并输出 bar。

```javascript
function foo() {
  var a = 'bar'
  console.log(a)
}
foo()
```

&emsp;对以上代码稍加改动，使其变为如下形式。

```javascript
var b = 'bar'
function foo() {
  console.log(b)
}
foo()
```

&emsp;执行以上代码时，foo 函数在自身函数作用城内并未找到 b 变量，但是它会继续向外扩大查找范围，于是便在全局作用城中找到了变量b，井输出 bar。

&emsp;如果我们再对代码稍加改动，使其变成如下形式，结果又将如何呢?

```javascript
function bar() {
  var b = 'bar'
}

function foo() {
  console.log (b) 
}
foo()
```

&emsp;在以上代码中，foo 和 bar 分属于两个彼此独立的函数作用城，foo 函数无法访问 bar 函数中定义的变量 b，且其作用域链内(直到上层全局作用城中)也不存在相应的变量，因此执行这段代码会报错 Uncaught ReferenceError: b is not defined。

&emsp;简单总结下，在 JavaScript 中执行某个函数时，如果遇见变量且需要读取其值，就会“就近”先在函数内部查找该变量的声明或赋值情况。这里涉及“变量声明方式”及“变量提升”等知识点， 后面的篇章会做进一步讲解。 如果在函数内无法找到该变量，就要跳出函数作用域，到更上层作用域中查找。这里的“更上层作用域”可能也是一个函数作用域。下面来看一个具体示例。

```javascript
function bar() {
  var b = 'bar'
  function foo() {
    console.log (b) 
  }
  foo()
}

bar()
```

&emsp;在 foo 函数执行时，变量 b 的声明或赋值情况是在其上层函数 bar 的作用域中获取的。另外，更上层作用域也可以顺着作用域范围向外扩散，一直到全局作用域，示例如下。

```javascript
var b = 'bar'
function bar() {
  function foo() {
    console.log (b) 
  }
  foo()
}

bar()
```

&emsp;执行以上代代码回输出 bar 这是因为执行 foo 函数时，在其作用城链上最终找到了全局作用城下的变量 b。我们看到，变量作用城的查找是一个扩 散过程，就像各个环节相扣的链条，逐次递进，这就是“作用城链”的由来。



#### 块级作用域和暂时性死区

&emsp;作用域概念不断演进，ES6 中增加了通过 let 和 const 声明变量的块级作用域，使得 JavaScript 中的作用城内涵更加丰富。块级作用域，顾名思义，是指作用域范围限制在代码块中，这个概念在其他语言中也普遍存在。当然，这些新特性的出现也增加了一定的复杂度，带来了新的概念，比如暂时性死区。这里有必要对此概念稍做展开，说到暂时性死区，还需要从“变量提升”说起，请参看以下代码。

```javascript
function foo() {
  console.log(bar)
  var bar = 3
}
foo()
```

&emsp;执行以上代码会输出 undefined，原因是变量 bar 在函数内进行了提升。以上代码与以下代码是等价的。

```javascript
function foo() {
  var bar
  console.log(bar)
  bar = 3
}
foo()
```

&emsp;但是，在使用 let 对 bar 进行声明时(如下所示则会报错 Uncaught ReferenceError: bar is not defined。

```javascript
function foo() {
  console.log(bar)
  let bar = 3
}
foo()
```

&emsp;我们知道，用 let 或 const 声明变量时会针对这个变量形成个封间的块级作用城， 在这个块级作用城中，如果在声明变量前访问该变量，就会报 refernceError 错误：如果在声明变量后访问该变量，则可以正常获取变量值，示例如下。

```javascript
function foo() {
  let bar = 3
  console.log(bar)
}
foo()
```

&emsp;以上代码将正常输出 3。因此，在相应花括号形成的作用域中存在一个“`死区`”，起始于函数开头。终止于相关变量声明语句的所在行。在这个范围内无法访问使用 let 或 const 声明的变量。这个 “`死区`”的专业名称为 TDZ( Temporal Dead Zone )，相关语言规范的介绍可参考ECMAScript 2015 Language Specification，喜欢刨根问底的读者可以了解一下。

&emsp;