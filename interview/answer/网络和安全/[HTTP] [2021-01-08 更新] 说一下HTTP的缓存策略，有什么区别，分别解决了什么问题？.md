### 一、浏览器的缓存策略

​	浏览器每次发起请求时，现在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使用本地缓存；否则，则向服务器发起请求并携带缓存标识。

​	根据是否需要向服务器发起HTTP请求，将缓存过程划分为两个部分：强制缓存和协商缓存，强制缓存优先于协商缓存。

	* **强缓存** ，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。
	* **协商缓存** ，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modied通过请求发送给服务器，有服务器校验，返回304状态码时，浏览器直接使用缓存。

HTTP缓存都是从第二次请求开始的：

	* 第一次请求资源时，服务器返回资源，并在response header中回传资源的缓存策略；
 * 第二次请求时，浏览器判断这些请求参数，击中强缓存就直接返回200，否则就把请求参数加到request header头中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。这是缓存运作的一个整体流程图：
   	* ![image-20210108235425590](/Users/gongjin/Library/Application Support/typora-user-images/image-20210108235425590.png)

#### 1.1  强缓存

	* 强缓存命中则直接读取浏览器本地的资源，在network中显示的是from memory和from disk
	* 控制强制缓存的字段有：Cache-Control（http1.1）和 Expires（http1.0）
	* Cache-Control是一个相对时间，用以表达自上次请求正确资源之后的多少秒的时间段内缓存有效。
	* Expires是一个绝对时间。用以表达在这个时间点之前发起请求可以直接从浏览器中读取数据，而无需发起请求。
	* Cache-Control的优先级比Expires的优先级高，前者出现是为了解决Expires在浏览器时间被手动更改导致缓存判断错误的问题。如果同时存在则使用Cache-Control.



##### 	1.1.1 强缓存 expires

		* 该字段是服务器响应消息头字段，告诉浏览器在过期时间之前可以直接从浏览器缓存中存取数据。
		* Expires是HTTP1.0的字段，表示缓存到期时间，是一个绝对的时间（当前时间+缓存时间）。在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求。
		* 由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源。此外，及时不考虑吧修改，时差或者误差等因素也可能造成客户端与服务端的时间不一致，致使缓存失效。

###### 优势特点

	* HTTP 1.0的产物，可以在HTTP1.0和1.1中使用，简单易用。
	* 以时刻标识失效时间

##### 强缓存 Cache-Control

	* 已知Expires缺点之后，在HTTP1.1中，增加了一个字段Cache-Control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求。
	* 这两者的区别就是前者是绝对时间，而后主卧室相对时间，具体属性可查询MDN



#### 1.2  协商缓存

* 协商缓存的状态码由服务器决策返回200或者304
* 当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since或者If-None-Match的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中，则返回304，加载浏览器缓存，并且响应头会设置Last-Modified或者Etag属性。
* 对比缓存在请求书上和没有缓存是一致的，但如果是304的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此，在响应体积上的节省是它的优化点。
* 协商缓存有两组字段（不是两个），控制协商缓存的字段有：Last-Modified/If-Modifed-Since(http1.0)  和  Etag/If-None-Match (Http1.1)
* Last-Modified/If-Modified-Since表示的是服务器资源最后一次修改的时间； Etag/If-Nono-Match表示的是服务器资源的唯一标识，只要资源变化，Etag就会重新生成。